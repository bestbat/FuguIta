#!/bin/sh

#========================================
#
# usbfadm - USB Flash drive ADMinistration tool
# KAWAMATA, Yoshihiro / kaw@on.rim.or.jp
#
#========================================

# Copyright (c) 2006--2019
# Yoshihiro Kawamata
#
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
# 
#   * Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 
#   * Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in
#     the documentation and/or other materials provided with the
#     distribution.
# 
#   * Neither the name of Yoshihiro Kawamata nor the names of its
#     contributors may be used to endorse or promote products derived
#     from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#==================================
# Utility functions and subcommands
#==================================

#-------------------
# clean-ups
#
function clear_exit {
    if mount | grep -q "^$devname on /mnt" ;then
        umount $devname
    fi
    rm -rf $lockdir
    exit $1
}

#-------------------
# Wait for ENTER key pressed
# outputs results to stdout
#
#     usage: wait_enter prompt
#
#       output ... 1: ENTER key pressed
#                 -1: Key pressed but not ENTER
#                 -2: Error occured
#
function wait_enter {
    local prompt="$1"
    local line

    echo -n "$prompt -> " >&2; read line

    if [ X"$line" = X ]; then
        echo 1
    else
        echo -1
    fi
}

#-------------------
# ask user yes or no
# outputs answer to stdout
#
#     usage: ask_yn prompt yn
#
#       yn ... y: defaults to yes
#              n: defaults to no
#              r: no default ... ask again
#              else: no default ... return -1 if answered not yn
#
#       output ... 1: yes, 0: no, -1: else yn, -2: error occured
#
function ask_yn {

    if [ -z "$2" ]; then
        echo -2 >&2
        return
    fi

    local prompt="$1"; shift
    local yn_default="$1"; shift
    local yn_ans

    case X"$yn_default"X in
        X[Yy]X) yn_default=Y; prompt="$prompt [Y/n] -> " ;;
        X[Nn]X) yn_default=N; prompt="$prompt [y/N] -> " ;;
        X[Rr]X) yn_default=R; prompt="$prompt [y/n] -> " ;;
        *)      yn_default=E; prompt="$prompt [y/n] -> " ;;
    esac

    while :; do
        echo -n "$prompt" >&2; read yn_ans

        case X"$yn_ans"X in
            X[Yy]X) echo 1; return;;
            X[Nn]X) echo 0; return;;
            XX)
                case X"$yn_default"X in
                    XYX) echo 1;  return;;
                    XNX) echo 0;  return;;
                    XRX) continue;;
                    *)   echo -1; return;;
                esac;;
            *)
                continue;;
        esac
    done
}

#-------------------
# ask selection out of multiple items
# outputs answer to stdout
#
#     usage: ask_which prompt default item1 item2 ...
#
#       Note: although user's choice is one originated
#             default is zero originated
#
#       output: first word of selected item
#               returns empty line unless selected normally
#
function ask_which {
    if [ $# -lt 3 ]; then
        return
    fi

    local prompt="$1";  shift
    local default="$1"; shift
    local i item val

    # skip null item
    #
    i=0
    for val in "$@"; do
        if [ -n "$val" ]; then
           item[$i]="$val"
           i=$((i+1))
        fi
    done

    # only one item is default itself
    #
    [ "${#item[@]}" = 1 ] && default=${item[0]}

    i=0
    while [ -n "${item[$i]}" ]; do
        if [ "$default" = "${item[$i]}" ]; then
            OIFS="$IFS"
            IFS= prompt="$prompt\n"`printf '%3d: [%s]' $((i+1)) ${item[$i]}`
            IFS="$OIFS"
        else
            OIFS="$IFS"
            IFS= prompt="$prompt\n"`printf '%3d:  %s' $((i+1)) ${item[$i]}`
            IFS="$OIFS"
        fi
        i=$((i+1))
    done
    echo "$prompt" >&2

    local ans
    ans=`rl_wread '' ''`

    # take first argument
    #
    set -- $ans
    ans=$1
    
    # return selected item
    #
    if expr "$ans" : '^[0-9][0-9]*$' >/dev/null && \
       [ "$ans" -le ${#item[@]} ]; then
        set -- ${item[$((ans-1))]}
        echo $1
    elif [ -n "$default" -a -z "$ans" ]; then
        set -- $default
        echo $1
    fi
}

#-------------------
# read user's input with readline functionality
# outputs echoed to stdout
#
#     usage: rl_wread prompt-str default-str [completion words ....]
#
function rl_wread {
    local prompt="$1";  shift
    local default="$1"; shift

    if [ -x /usr/local/bin/rlwrap ]; then
        echo "$@" > $lockdir/rl_words
        rlwrap -b '' \
               -f $lockdir/rl_words \
               -P "$default" \
               sh -f -c 'echo -n "'"$prompt"'->" >&2 ; read w || echo EOF; echo $w' || echo RL_ERR
    else
        #-------------------
        # fallback to dumb input
        #
        if [ X"$default" = X ]; then
            echo -n "${prompt}->" >&2
            read w
        else
            echo -n "$prompt [$default] -> " >&2
            read w
            if [ X"$w" = X ]; then
              w="$default"
            fi
        fi
        echo $w
    fi
}

function notice {
    echo ''
    echo ========================================
    echo = "$@"
    echo =
}

#-------------------
# convert bytes to sectors
# bytes can be suffixed by 'k', 'm', 'g' or 't'
#
# Outputs to stdout
#   null string unless converted sucessfully
#
function byte2sect {
    local args=$@  # concat all arguments as a string
    local val
    val=$(expr "$args" : '0*\([1-9][0-9]*\) *[Tt][Bb]*$') && { echo "$((1024*1024*1024*1024*val/sect_size))"; return; }
    val=$(expr "$args" : '0*\([1-9][0-9]*\) *[Gg][Bb]*$') && { echo "$((1024*1024*1024*val/sect_size))";      return; }
    val=$(expr "$args" : '0*\([1-9][0-9]*\) *[Mm][Bb]*$') && { echo "$((1024*1024*val/sect_size))";           return; }
    val=$(expr "$args" : '0*\([1-9][0-9]*\) *[Kk][Bb]*$') && { echo "$((1024*val/sect_size))";                return; }
    val=$(expr "$args" : '0*\([1-9][0-9]*\) *[Bb]*$')     && { echo "$((val/sect_size+1))";                   return; }
    val=$(expr "$args" : '00*') && { echo 0; return; }
}

#-------------------
# convert sectors to bytes
#
# Outputs to stdout
#   null string unless converted sucessfully
#
function sect2byte {
    local val
    val=$(expr "$1" : '00*$') && { echo "0B"; return; }
    if val=$(expr "$1" : '\([1-9][0-9]*\)'); then
        val=$((sect_size*val))
        [ "$val" -lt 1024 ] && { echo "${val}B"; return; }
        val=$((val/1024)); [ "$val" -lt 1024 ] && { echo "${val}KB"; return; }
        val=$((val/1024)); [ "$val" -lt 1024 ] && { echo "${val}MB"; return; }
        val=$((val/1024)); [ "$val" -lt 1024 ] && { echo "${val}GB"; return; }
        val=$((val/1024)); echo "${val}TB"; return
    fi
}

#-------------------
# scan specified disk
# then outputs its parameters with form of sh var assignment
#
# Usage: eval `disk_scan disk`
#
# Outputs: scandev    : name of device, e.g. 'sd0'
#          sect_size  : sector size - bytes/sector
#          sects_trk  : number of sectors per track
#          sects_total: number of total sectors
#          diskscan   : result of scan - 'ok' or 'ng'
#
function disk_scan {
    [ -z "$1" ] && return
    disklabel -c "$1" | awk '
BEGIN {
    paramfound = 0
    print "scandev='"$1"'"
}
$1 == "bytes/sector:"  { sect_size=$2;   print "sect_size=" sect_size; paramfound++; }
$1 == "sectors/track:" { print "sects_trk=" $2; paramfound++ }
$1 == "boundstart:"    { print "bound_start=" $2; paramfound++ }
$1 == "boundend:"      { print "bound_end=" $2; paramfound++ }
/^total sectors: /     { sects_total=$3; print "sects_total=" $3; paramfound++; }
END {
    if (paramfound==5) {
        print "diskscan=ok"
    } else
        print "diskscan=ng"
}'
}

#-------------------
# show global parameters
#
# Usage: showparams ['verbose']
#
#   verbose is for debug output
#
function showparams {

    # global variables for newdrive subcommand
    # 
    # global parameters
    #    bootmode   : initial boot mode - e.g. 'usbflash'
    #    devname    : path of target device for sync - e.g. 'sd0d'
    #    devnames   : all disk names attached to this machine
    #    uconf      : name of configuration - e.g. 'nimbus12-userdemo'
    # 
    # constatns
    #    fuguita_sys_mb : system size of FuguIta in MB, normaly 700
    #    fuguita_uefi_kb: Partition size for EFI Sys
    #    osrel      : OpenBSD's release - e.g. '6.4'
    #    hwmac      : name of the platform - e.g. 'amd64'
    #    verarch    : $osrel/$hwmac
    # 
    # target disks
    #    newdev     : device name to newdrive - e.g. 'sd0'
    #    parttype   : partition type - MBR/GPT/Hybrid
    #    instsys    : boot type - none/mbr (should be none/Legacy/UEFI)
    # 
    # results of disk_scan()
    #    scandev    : name of device, e.g. 'sd0'
    #    sect_size  : sector size - bytes/sector
    #    sects_trk  : number of sectors per track
    #    sects_total: number of total sectors
    #    bound_start: start of OpenBSD boundary
    #    bound_end  : end of OpenBSD boundary
    #    diskscan   : result of scan - 'ok' or 'ng'
    # 
    # partition sectors (ps_ for short)
    #
    #    ps_free : available sectors for user's partitioning
    #    ps_hgap : head gap (for MBR/GPT and disklabel)
    #    ps_uefi : sectors for UEFI (partition i)
    #    ps_fisys: sectors for FuguIta's system (partition a)
    #    ps_fidat: sectors for FuguIta's Data Store (partition d)
    #    ps_fat  : sectors for Data Exchange (partition i or j)
    #    ps_tgap : tail gap (for GPT)
    # 
    # vnode devices
    #
    #    vnfile  : raw disk image file

    echo
    echo "target disk: $scandev"
    echo "  partition type=$parttype"
    echo "       boot type=$instsys"
    echo
    if [ "$1" = verbose ]; then
        cat<<EOT | awk 'BEGIN{FS=","} {printf("%20s : %10s\n", $1, $2)}'
--------------------,----------
partition,size
--------------------,----------
whole disk,$sects_total
partition tables,${ps_hgap}+${ps_tgap}
UEFI system,$ps_uefi
FuguIta system,$ps_fisys
FuguIta user data,$ps_fidat
MSDOS FAT,$ps_fat
--------------------,----------
EOT
        echo
        echo '===== fdisk =========='
        fdisk -v $scandev | egrep '[0-9]: |^(Primary GPT|Secondary GPT|MBR):'
        echo
        echo '===== disklabel ======'
        disklabel -c $scandev | egrep '^  [a-p]:|^bound'
    else
        cat<<EOT | awk 'BEGIN{FS=","} {printf("%20s : %6s\n", $1, $2)}'
--------------------,------
partition,size
--------------------,------
whole disk,`sect2byte $sects_total`
partition tables,`sect2byte $((ps_hgap+ps_tgap))`
UEFI system,`sect2byte $ps_uefi`
FuguIta system,`sect2byte $ps_fisys`
FuguIta user data,`sect2byte $ps_fidat`
MSDOS FAT,`sect2byte $ps_fat`
--------------------,------
EOT
    fi
}

#-------------------
# zero-filling specified disk 1MB from the head
#
#     Usage: zerofill_head
#
# results of previous execution of disk_scan affects this.
#
function zerofill_head {
    notice "Clearing MBR, GPT and BSD disklabel"
    [ "$diskscan" = ok ]  || return

    # clear partition table and disklabel
    dd if=/dev/zero of=/dev/r"$scandev"c bs=$((2048*sect_size)) count=$(((bound_start+`byte2sect 1M`)/2048))
}

#-------------------
# setup MBR type fdisk partitions
#
#     Usage: fdisk_init partition-type
#
# results of previous execution of disk_scan affects this.
#
function fdisk_init {
    [ "$diskscan" = ok ]  || return
    [ -z "$1" ] && return

    local ptype="$1"

    if [ ! $secs_total = $((ps_hgap+ps_uefi+ps_fisys+ps_fidat+ps_fat+ps_tgap)) ]; then
        echo "Inconsistent sector sizes: $secs_total != $ps_hgap + $ps_uefi + $ps_fisys + $ps_fidat + $ps_fat + $ps_tgap"
        return
    fi

    notice "Setting up fdisk partitions"

    if [ "$debugfile" ]; then
        { echo
          echo "////////// fdisk_init ////////////////////////////////////////"
          showparams verbose
        } >> "$debugfile"
    fi

    # - initialize partition table
    # - build input string for fdisk
    #
    local fdisk_input=''
    case "$ptype" in
        MBR)
            fdisk -iy $scandev
            [ 0 -lt $ps_uefi ] && fdisk_input="e 0\nEF\nn\n${ps_hgap}\n${ps_uefi}\n"
            [ 0 -lt $ps_fat ]  && fdisk_input="${fdisk_input}e 2\n0C\nn\n$((ps_hgap+ps_uefi+ps_fisys+ps_fidat))\n${ps_fat}\n"
            [ 0 -lt $((ps_fisys+ps_fidat)) ] && fdisk_input="${fdisk_input}e 3\nA6\nn\n$((ps_hgap+ps_uefi))\n$((ps_fisys+ps_fidat))\n"
            fdisk_input="${fdisk_input}quit\n"
            ;;
        GPT)
            fdisk -igy $scandev
            [ 0 -lt $ps_uefi ] && fdisk_input="e 1\nEF\n${ps_hgap}\n${ps_uefi}\nUEFI Boot\n"
            [ 0 -lt $ps_fat ]  && fdisk_input="${fdisk_input}e 2\n0C\n$((ps_hgap+ps_uefi+ps_fisys+ps_fidat))\n$ps_fat\nMSDOS FAT\n"
            [ 0 -lt $((ps_fisys+ps_fidat)) ] && fdisk_input="${fdisk_input}e 3\nA6\n$((ps_hgap+ps_uefi))\n$((ps_fisys+ps_fidat))\nOpenBSD Area\n"
            fdisk_input="${fdisk_input}quit\n"
            ;;
        Hybrid)
            fdisk -iy $scandev
            fdisk_input="e 0\nEE\nn\n1\n*\n"
            [ 0 -lt $ps_uefi ] && fdisk_input="${fdisk_input}e 1\nEF\nn\n${ps_hgap}\n${ps_uefi}\n"
            [ 0 -lt $ps_fat ]  && fdisk_input="${fdisk_input}e 2\n0C\nn\n$((ps_hgap+ps_uefi+ps_fisys+ps_fidat))\n$ps_fat\n"
            [ 0 -lt $((ps_fisys+ps_fidat)) ] && fdisk_input="${fdisk_input}e 3\nA6\nn\n$((ps_hgap+ps_uefi))\n$((ps_fisys+ps_fidat))\n"
            fdisk_input="${fdisk_input}quit\n"
            ;;
    esac

    # invoke fdisk
    #
    if [ -n "$fdisk_input" ]; then
        if [ "$debugfile" ]; then
            { echo
              echo "===== fdisk input ====="
              echo "$fdisk_input"
            } >> "$debugfile"
        fi
        echo -n "$fdisk_input" | fdisk -e "$scandev"
    fi
}

#-------------------
# setup OpenBSD's partition and all filesystems
#
#     usage: setup_fs
#
# With "Legacy", partition a is prepared and
# FuguIta system will be copied.
#
function setup_fs {
    [ "$diskscan" = ok ]  || return

    if [ 0 -eq `expr "$scandev" : '^[sw]d[0-9]$'` ] &&
       [ 0 -eq `expr "$scandev" : '^vnd[0-9]$'` ]; then
        return
    fi

    notice "Setting up disklabel and FFS partitions"

    if [ "$debugfile" ]; then
        { echo
          echo "////////// setup_fs ////////////////////////////////////////"
          showparams verbose
        } >> "$debugfile"
    fi

    # build input string for disklabel
    #
    local disklabel_input='' part

    # commands to delete existing FFS/swap partitions
    for part in `disklabel -c $scandev | awk '/^  [a-p]: .*  (4\.2BSD|swap)/{print $1}' | tr -d :`; do
        disklabel_input="${disklabel_input}d $part\n"
    done

    # commands to create new FFS partitions
    [ 0 -lt $ps_fisys ] && disklabel_input="${disklabel_input}a a\n$((ps_hgap+ps_uefi))\n${ps_fisys}\n4.2BSD\n"
    [ 0 -lt $ps_fidat ] && disklabel_input="${disklabel_input}a d\n$((ps_hgap+ps_uefi+ps_fisys))\n*\n4.2BSD\n"
    disklabel_input="${disklabel_input}q\ny\n"

    # invoke disklabel
    #
    if [ -n "$disklabel_input" ]; then
        if [ "$debugfile" ]; then
            { echo
              echo "===== disklabel input ====="
              echo "$disklabel_input"
            } >> "$debugfile"
        fi
        echo -n "$disklabel_input" | disklabel -c -E "$scandev"
    fi

    local disklabel=`disklabel -c $scandev`

    echo "$disklabel" | grep -q 'i:.*MSDOS' && newfs_msdos ${scandev}i
    echo "$disklabel" | grep -q 'j:.*MSDOS' && newfs_msdos ${scandev}j

    if echo "$disklabel" | grep -q 'a:.*4\.2BSD'; then
        # very few files ... make inode density low
        newfs -m0 -i$((fuguita_sys_mb*1024*1024/100)) ${scandev}a

        notice "Copying FuguIta system files"

        mount -o async /dev/${scandev}a /mnt
        (cd /sysmedia
         pax -rwvpe !(fuguita-${osrel}-${hwmac}.ffsimg) /mnt)

        if [ -r /sysmedia/fuguita-${osrel}-${hwmac}.ffsimg ]; then
            notice "Transferring filesystem image"
            (sleep 15; while pkill -INFO dd; do sleep 15; done) &  # to display progress
            dd if=/sysmedia/fuguita-${osrel}-${hwmac}.ffsimg of=/mnt/fuguita-${osrel}-${hwmac}.ffsimg bs=1m
        fi

        case $instsys in
            Legacy|Hybrid)
                notice "Installing BIOS boot loader"
                /usr/sbin/installboot -v -r /mnt ${scandev} /usr/mdec/biosboot /usr/mdec/boot
                umount /mnt
                ;;
            UEFI)
                umount /mnt
                notice "Installing UEFI boot loader"
                /usr/sbin/installboot -v ${scandev} /fuguita/usr/mdec/biosboot /fuguita/usr/mdec/boot
                if mount /dev/${scandev}i /mnt; then
                    if ! ls -ld /mnt/efi/BOOT/*.[Ee][Ff][Ii] 2>&1 | grep -q '^-'; then
                        notice "installboot failed, taking workaround..."
                        set -x
                        mkdir -p /mnt/efi/BOOT
                        cp /fuguita/usr/mdec/*.EFI /mnt/efi/BOOT
                        [ "$opt_trace" != yes ] && set +x
                    fi
                    umount /mnt
                fi
                ;;
        esac

        fsck -fy /dev/r${scandev}a
    fi

    if echo "$disklabel" | grep -q 'd:.*4\.2BSD'; then
        notice "Setting up a partition for user's data"
        if [ $ps_fidat -le `byte2sect 2G` ]; then
            # adjust inode density for little space
            # because too many symlinks when booted mode 0
            newfs -m0 -i1024 -b4096 -f512 ${scandev}d
        else
            newfs -m0 ${scandev}d
        fi

        mount -o async /dev/${scandev}d /mnt
        mkdir /mnt/livecd-config
        cat <<EOT >/mnt/noasks
#
# noasks - parameter settings for non-interactive boot
#
# Make statements uncommented
# to activate settings
#
#
# FuguIta system device
#noask_rdev='${scandev}a'
#
# tmpfs size in MB
#noask_umem='0'
#
# boot mode
#noask_setup_rw_mode='3'
#
# storage device
#noask_confdev='${scandev}d'
#
# data set name in USB flash drive
#noask_confdir=`hostname -s`
EOT
        umount /mnt

        fsck -fy /dev/r${scandev}d
    fi
}

#-------------------
# clean-ups for vnode device
#
#     usage: clear_vn vn_device vn_img_rm
#
#    vn_device : vnode to be unattached 
#    vn_img_rm : remove this file if specified
#
function clear_vn {
    local vndev="$1"
    local vnrm="$2"

    case "$vndev" in
        vnd[0-3])
            if vnconfig -l | grep -q "^$vndev: covering "; then
                vnconfig -u "$vndev"
                fi
            ;;
    esac
    [ -n "$vnrm" ] && rm -f $vnrm
}

#==================================
# Active Code from HERE.
#==================================

#-------------------
# systemwide constants
#
lockdir=/tmp/usbfadm.lock
  osrel=`sysctl -n kern.osrelease`
  hwmac=`sysctl -n hw.machine`
verarch=${osrel}/${hwmac}

#-------------------
# environment check
#
if [ ! -r /usr/fuguita/version ]; then
    echo "You are not running FuguIta."
    exit 1
fi

if [ ! `id -un` = root ]; then
    echo "$0 must be run as a root."
    exit 1
fi

if ! pwd >/dev/null 2>&1; then
    # in case of cwd already unmounted
    cd /
elsif [ 1 -le $(expr $(pwd) : /mnt) ]
    echo ''
    echo 'You are under /mnt. Please move to other directory.'
    exit 1
fi

umask_o=`umask`; umask 077
if ! mkdir $lockdir 2>/dev/null; then
    umask $umask_o
    echo "another $0 running (or remove $lockdir)"
    exit 1
fi
umask $umask_o

#-------------------
# initializations
#
trap 'echo $0: interrupted. >&2; clear_exit 1' INT

# read status files
#
[ -r /boottmp/boot_mode ]            && bootmode=`cat /boottmp/boot_mode`
[ -r /boottmp/boot_restore_devname ] && devname=`cat /boottmp/boot_restore_devname`
[ -r /boottmp/boot_user_config ]     && uconf=`cat /boottmp/boot_user_config`

# systemwide defaults
#
  disk_head_gap=64
 fuguita_sys_mb=700
fuguita_uefi_kb=512
#
# overwrite defaults
#
[ -r /usr/fuguita/etc/usbfadm.conf ] && . /usr/fuguita/etc/usbfadm.conf

# command line arguments
#
cmdargs=`getopt qrtdh $*`
set -- $cmdargs
while [ 1 -lt $# ]; do
    case "$1" in
        -r) opt_mode=resync; shift;;
        -q) opt_quiet=yes;   shift;;
        -t) opt_trace=yes; set -x; shift;;
        -d) debugfile=`pwd`/usbf.debugout  # This is also flag.
            shift;;
        *) cat <<EOT 2>&1
Usage: $0 [-rqtdh]

    -r : redo sync non-interactively
        (must run 'sync' at interactive mode before doing this)
    -q : quiet mode when redo sync
    -t : trace output (pass -x to shell)
    -d : debug output for newdrive to file 'usbf.debugout'
    -h : print this help
EOT
           clear_exit 0
           ;;
    esac
done
[ "$debugfile" ] && rm -f "$debugfile"

#-------------------
# non-interactive process
#
if [ "$opt_mode" = 'resync' ]; then
    if [ -z "$devname" ]; then
        echo "$0: Name of device isn't set. Use 'target', then 'sync' in interactive mode."
        clear_exit 1
    elif [ -z "$uconf" ]; then
        echo "$0: Name of saving data isn't set. Use 'saveas', then 'sync' in interactive mode."
        clear_exit 1
    fi

    if mount -o softdep,noatime $devname /mnt; then
        if [ "$opt_quiet" = 'yes' ]; then
            rsync -aqHxS --delete --include '*/tmp' --exclude 'tmp/*' /ram/. /mnt/livecd-config/$verarch/$uconf/.
        else
            notice "Sync current tmpfs as $uconf into $devname"
            rsync --progress -avHxS --delete --include '*/tmp' --exclude 'tmp/*' /ram/. /mnt/livecd-config/$verarch/$uconf/.
        fi
        # find /mnt \! -type d \! -type f \! -type l -print | xargs rm -f
        rm -rf /mnt/livecd-config/$uconf/tmp/{.??*,*}
        sync
        sleep 5
        umount $devname
    fi
    clear_exit 0
fi

#-------------------
# interactive process
#   banner and command loop
#
d=$devname ; [ -z "$devname" ] && d='not set'
u=$uconf   ; [ -z "$uconf" ]   && u='not set'
cat <<EOT

Welcome to usbfadm.
USB flash drive administration tool for FuguIta

  Version/Arch: $verarch  (FuguIta-`cat /usr/fuguita/version`)
     Boot mode: $bootmode
Data stored in: $d
 Data Saved as: $u

Type ? for help.
EOT

while :; do
    #-------------------
    # setup prompt string
    #
    d="${devname#/dev/}" ; [ -z "$devname" ] && d='?'
    u="$uconf"           ; [ -z "$uconf" ]   && u='?'
    echo ''
    cmd=`rl_wread "$d : $u " '' quit bye exit sync info saveas target newdrive help ?`

    set X $cmd

    #-------------------
    # process every command
    #
    case X"$2" in
        #-------------------
        # finish all
        #
        Xq|Xquit|Xbye|Xexit|XEOF|XRL_ERR)
        echo ''
        echo 'Bye bye...'
        break;
        ;;

        #-------------------
        # write back memory file system
        # to USB flash drive
        #
        Xsync)
        echo ''
        if [ X"$devname" = X ]; then
            echo "Name of device not set. Use 'target' to perform it."
            continue
        fi
        if [ X"$uconf" = X ]; then
            echo "Name of saving data not set. Use 'saveas' to perform it."
            continue
        fi

        if [ 1 = `ask_yn "Sync current tmpfs as \\\`\\\`$uconf'' , OK?" n` ]; then
            if mount -o softdep,noatime $devname /mnt &&
               mkdir -p /mnt/livecd-config/$verarch/$uconf; then
                echo ''
                rsync --progress -avHxS --delete --include '*/tmp' --exclude 'tmp/*' /ram/. /mnt/livecd-config/$verarch/$uconf/.
                # find /mnt \! -type d \! -type f \! -type l -print | xargs rm -f
                rm -rf /mnt/livecd-config/$verarch/$uconf/tmp/{.??*,*}
                sync
                sleep 5
                umount $devname
                echo "$devname" > /boottmp/boot_restore_devname
                echo "$uconf"   > /boottmp/boot_user_config
            fi
        fi
        ;;

        #-------------------
        # show status of USB flash drive
        #
        Xinfo)
        if mount -r $devname /mnt; then
            (cd /mnt/livecd-config && echo '' && df -hi /mnt && echo "\nscanning...\n" && du -sh [1-9].[0-9]/*/* [1-9].[0-9]-*-*) 2>/dev/null
            umount $devname
        fi
        ;;

        #-------------------
        # set data set name
        # default is our FQDN.
        #
        Xsaveas)
        if [ X"devname" != X ] && mount $devname /mnt; then
            [ -d /mnt/livecd-config/$verarch ] || mkdir -p /mnt/livecd-config/$verarch
            confs=`cd /mnt/livecd-config/$verarch && echo *`
            umount $devname
        fi
        [ X"$uconf" = X ] && uconf=`hostname -s`
        uconf=`rl_wread "Name of saved data" $uconf $confs`
        uconf=`echo $uconf | tr -cd 0-9A-Za-z.,_-+=:%@`  # strip invalid chars
        echo ''
        if [ X"$uconf" = X ]; then
            echo "Unset the name of saving data"
        else
            echo "Your data will be saved as \`\`$uconf''."
        fi
        ;;

        #-------------------
        # search and set USB flash drive
        #
        Xtarget)
        echo ''
        echo 'Searching USB flash drives'
        echo 'Please make sure the device inserted.'
        [ `wait_enter 'Then press ENTER'` -lt 1 ] && continue

        #-----------------------
        # search partitions for saved data
        #
        devname=''
        devnames=''
        for rdev in `sysctl -n hw.disknames | sed -E -e 's/:[0-9a-f]+/:/g; s/[:,]+/ /g;'`; do
            case $rdev in
                [csw]d[0-9]*)
                    for rdevp in `disklabel -c -pm $rdev 2>/dev/null \
                                  | sed -E -e '/^  [abd-p]: /!d; s/^  (.):/'$rdev'\1/' \
                                  | cut -d' ' -f1`; do
                        if mount -r /dev/$rdevp /mnt 2>/dev/null ; then
                            if [ -d /mnt/livecd-config ]; then
                                devname=${rdevp#/dev/}
                                devnames="$devnames $devname"
                                echo -n "+$rdevp "
                            else
                                echo -n "$rdevp "
                            fi
                            umount /mnt
                        else
                            echo -n "$rdevp "
                        fi
                    done
                    ;;
            esac
        done
        echo ''
        echo ''

        if [ X"$devnames" = X ]; then
            echo 'No device available for saving data'
        else
            devname=/dev/`rl_wread "target device" $devname $devnames`
        fi
        ;;

        #-------------------
        # make new FuguIta USB flash drive
        #
        Xnewdrive)

        echo ''
        if mount | grep -q '^\/dev\/[0-9a-z][0-9a-z]* on \/sysmedia type '
        then
            echo 'Please make sure the device inserted.'
            [ `wait_enter 'Then press ENTER'` -lt 1 ] && continue
        else
            echo 'Sorry, cannot find /sysmedia.  You cannot do newdrive with this boot mode.'
            continue
        fi

        echo ''
        echo '==== disk(s) and vnode devices  ============================'
        dmesg | sed -e '/^[sw]d[0-9][0-9]*[ :]/!d; s/> .*/>/'
        vnconfig -l
        echo '============================================================'
        newdev=`rl_wread "Enter the name of device which FuguIta will be installed" "" \`sysctl -n hw.disknames|tr :, \\\\\012|grep '^[s]d[0-9]$'\``
        if [ -z "$newdev" ]; then
            echo ''
            echo "newdrive: no device name"
            continue
        elif [ 0 -eq `expr "$newdev" : '^[sw]d[0-9]$'` ] && \
           [ 0 -eq `expr "$newdev" : '^vnd[0-9]*$'` ]; then
            echo ''
            echo "newdrive: device $newdev is not supported."
            continue
        fi

        if mount | grep -q "^/dev/$newdev"; then
            echo ''
            echo "newdrive: $newdev is already mounted."
            continue
        fi

        # create vnode device file if specified
        #
        case "$newdev" in
            vnd[0-3])
                if ! vnconfig -l | grep -q "^$newdev: not in use"; then
                    echo ''
                    echo "newdrive: vnode device $newdev is already used."
                    continue
                fi
                vnfile=FuguIta-$(</usr/fuguita/version).img
                if [ -e "$vnfile" ]; then
                    echo
                    [ 1 -gt `ask_yn "Image file $vnfile already exists\nRemove it and proceed?" r` ] && break
                fi
                while :; do
                    echo
                    echo "Enter size of a vnode device file."
                    echo "You can add suffix K, M, G or T (otherwise considered 'bytes')."
                    ans=`rl_wread '' ''`
                    echo
                    if [ 1 -lt `expr "X$ans" : 'X[0-9][0-9]*'` ]; then
                        sect_size=$((1024*1024)) # block size for dd
                        [ `byte2sect 724M` -le `byte2sect $ans` ] && break
                        [ 1 -le `ask_yn "$ans is very small value.\nDo you really take this value?" n` ] && break
                    fi
                done
                (sleep 15; while pkill -INFO dd; do sleep 15; done) &  # to display progress
                if dd if=/dev/zero of=$vnfile bs=$sect_size count=`byte2sect $ans` && \
                        vnconfig $newdev $vnfile; then
                    :  # normal exit
                else
                    clear_vn $newdev $vnfile
                    continue
                fi
                ;;
        esac

        echo ''
        if ! fdisk $newdev; then
            clear_vn $newdev $vnfile
            continue
        fi

        if [ `fdisk $newdev | grep -c ' unused      $'` != 4 ]; then
            echo ''
            echo 'This disk seems to have been partitioned already.'
            if [ `ask_yn "Continue anyway?" n` -lt 1 ]; then
                clear_vn $newdev $vnfile
                continue
            fi
        fi

        # get disk parameters
        #
        eval `disk_scan $newdev`
        if [ ! "$diskscan" = ok ]; then
            echo "cannot get parameters of $newdev"
            clear_vn $newdev $vnfile
            continue
        fi
        #
        # from here, $scandev is used as target device name instead of $newdev
        #

        # disable boot items if specified
        #
        legacyitem='Legacy BIOS'
        case "$disable_legacyboot" in [Yy][Ee][Ss]) unset legacyitem;; esac
        uefiitem='UEFI'
        case "$disable_uefiboot" in [Yy][Ee][Ss]) unset uefiitem;; esac
        unset hybriditem
        [ "$legacyitem$uefiitem" = 'Legacy BIOSUEFI' ] && hybriditem='Hybrid'

        #-------------------
        # ask boot method and partition type
        #
        if [ $sects_total -lt `byte2sect 2T` ]; then
            echo ''
            instsys=`ask_which "Select boot method:" 'Legacy BIOS' "$legacyitem" "$uefiitem" 'none (only for save data)' "$hybriditem"`

            echo ''
            case $instsys in
                Legacy)
                    parttype=MBR
                    ;;
                UEFI)
                    parttype=`ask_which "Select partition type:" GPT GPT MBR`
                    if [ "$parttype" = MBR ]; then
                        cat <<EOT

Notice:
  You have selected 'UEFI' as boot type
  and 'MBR' as partition type.

  This is NOT normal configuration for many platforms.

EOT
                        if [ 1 -gt `ask_yn "Proceed anyway?" n` ]; then
                            clear_vn $newdev $vnfile
                            continue
                        fi
                    fi
                    ;;
                none)
                    parttype=`ask_which "Select partition type:" MBR MBR GPT Hybrid`
                    ;;
                Hybrid)
                    cat <<EOT
Notice:
  You have selected 'Hybrid' as boot type.

  This can be booted from either Legacy BIOS or UEFI.
  And has two partition tables both MBR and GPT.

  This is NOT normal configuration.
  Modifying partition table later may cause any problem.

EOT
                    if [ 1 -gt `ask_yn "Proceed anyway?" n` ]; then
                        clear_vn $newdev $vnfile
                        continue
                    fi
                    parttype=Hybrid
                    ;;
                *)
                    echo "Select one of above."
                    clear_vn $newdev $vnfile
                    continue
                    ;;
            esac
            if [ -z "$parttype" ]; then
                echo "Select one of above."
                clear_vn $newdev $vnfile
                continue
            fi
        else
            echo ''
            instsys=`ask_which "Select boot method:" '' "$uefiitem" 'none (only for save data)'`
            parttype=GPT
        fi

        #-------------------
        # calculate sectors
        #
        ps_hgap=$disk_head_gap
        ps_uefi=0
        ps_fisys=0
        ps_fidat=0
        ps_fat=0
        case "$parttype" in
            GPT|Hybrid)
                ps_tgap=$ps_hgap ;;  # for 2nd GPT
            *)
                ps_tgap=0 ;;
        esac

        case "$instsys" in
            Legacy)
                ps_fisys=`byte2sect "${fuguita_sys_mb}M"`
                ;;
            UEFI|Hybrid)
                ps_uefi=`byte2sect "${fuguita_uefi_kb}K"`
                ps_fisys=`byte2sect "${fuguita_sys_mb}M"`
                ;;
            none)
                ;;
            *)
                echo "Select one of above."
                clear_vn $newdev $vnfile
                continue
                ;;
        esac
        ps_free=$((sects_total-(ps_hgap+ps_uefi+ps_fisys+ps_tgap)))

        #-------------------
        # ask and calculate User's data area
        # which is prepared as partition d
        #
        while :; do
            echo
            echo "Enter size for saving User Data."
            echo "  You can add suffix K, M, G or T (otherwise considered 'bytes')."
            echo "  '*' implies 'all'"
            echo "  '0' doesn't make this partition."
            echo
            echo "`sect2byte $ps_free` (${ps_free}sectors) free"
            ans=`rl_wread '' '*'`

            echo
            if [ 1 -lt `expr "X$ans" : 'X[0-9][0-9]*'` ]; then
                ps_fidat=`byte2sect "$ans"`
                if [ $ps_free -lt $ps_fidat ]; then
                    echo 'That size exceeds the limit.'
                    continue
                elif [ 0 -gt $ps_fidat -a $ps_fidat -lt `byte2sect 16M` ]; then
                    if [ 1 -le `ask_yn "$ans ($ps_fidat sectors) is very small value.\nDo you really take this value?" n` ]; then
                        break
                    else
                        continue
                    fi
                else
                    ps_free=$((ps_free-ps_fidat))
                    if [ 1 -le `ask_yn "Create an extra FAT partition?" r` ]; then
                        ps_fat=$ps_free
                        ps_free=0
                    fi
                fi
                break
            elif [ "X$ans" = 'X*' ]; then
                ps_fidat=$ps_free
                ps_free=0
                break
            else
                echo "$ans ... What?"
                continue
            fi
        done

        echo
        showparams

        echo
        echo '***THIS IS THE LAST CHANCE***'
        echo "If you type 'Y' now, all the data on $scandev will be lost."
        if [ `ask_yn "Are you sure to modify disk ${scandev}?" n` -lt 1 ]; then
            clear_vn $newdev $vnfile
            continue
        fi

        #-------------------
        # perform disk modifications
        #
        case "$parttype" in
            MBR|GPT)
                zerofill_head
                fdisk_init $parttype
                setup_fs
                ;;
            Hybrid)
                zerofill_head
                # first, create MBR partitions including UEFI Sys (ID=EF)
                fdisk_init $parttype
                setup_fs

                # save sector 0 (MBR) to a file
                dd if=/dev/r${scandev}c of=$lockdir/hybrid.mbr bs=$sect_size count=1

                # next, create a GPT with same contents as MBR's one
                # (also UEFI bootloader installed)
                fdisk_init GPT

                # install MBR boot loader, too
                if [ "$instsys" = Hybrid \
                       -a `expr "$disable_uefiboot" : '[Yy][Ee][Ss]'` -eq 0 ]; then
                    /usr/sbin/installboot -v ${scandev} /fuguita/usr/mdec/biosboot /fuguita/usr/mdec/boot
                    if mount /dev/${scandev}i /mnt; then
                        if ! ls -ld /mnt/efi/BOOT/*.[Ee][Ff][Ii] 2>&1 | grep -q '^-'; then
                            notice "installboot failed, taking workaround..."
                            set -x
                            mkdir -p /mnt/efi/BOOT
                            cp /fuguita/usr/mdec/*.EFI /mnt/efi/BOOT
                            [ "$opt_trace" != yes ] && set +x
                        fi
                        umount /mnt
                    fi
                fi

                # overwrite protective MBR with saved MBR
                dd if=$lockdir/hybrid.mbr of=/dev/r${scandev}c
                rm $lockdir/hybrid.mbr
                ;;
            *)
                echo "Partition type: '$parttype' - unknown" >&2
                ;;
        esac

        # site-specific post processing
        #
        [ -r /usr/fuguita/etc/usbfadm_postproc.sh ] && . /usr/fuguita/etc/usbfadm_postproc.sh

        if [ "$debugfile" ]; then
            { echo
              echo "////////// End of newdrive ////////////////////////////////////////"
              showparams verbose
            } >> "$debugfile"
        fi
        clear_vn $scandev  # don't remove vn img file
        ;;

        #-------------------
        # null command
        # ... only RET
        X)
        : # do nothing
        ;;

        #-------------------
        # other strings are invalid
        # then for help message
        #
        *)
        echo ''
        cat<<EOT
Interactive commands are;
    target    -  set USB device for sync and info
    saveas    -  set name of saving data
    sync      -  sync current tmpfs to the target device
    info      -  Show info on the target device
    newdrive  -  make new FuguIta USB flash drive
    bye, exit, quit
              - end of this utility

Command line options are;
    -r : redo sync non-interactively
        (must run 'sync' at interactive mode before doing this)
    -q : quiet mode when redo sync
    -t : trace output (pass -x to shell)
    -d : debug output for newdrive to file 'usbf.debugout'
    -h : print this help
EOT
        ;;
    esac
done

clear_exit 0
