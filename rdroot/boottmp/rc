# Copyright (c) 2006, 2007, 2008 Yoshihiro Kawamata
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
# 
#   * Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 
#   * Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in
#     the documentation and/or other materials provided with the
#     distribution.
# 
#   * Neither the name of the Yoshihiro Kawamata nor the names of its
#     contributors may be used to endorse or promote products derived
#     from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


(
 #====================
 # interim rc file for LiveCD
 #
 # KAWAMATA, Yoshihiro
 # kaw@on.rim.or.jp
 #

 cd /

 #====================
 # setup file systems;
 #   1. /         ...  ram disk attached to kernel
 #   2. /fuguita  ...  storage FuguIta is stored in
 #   3. /fuguita  ...  user-modifiable file system
 #

 #-------------------------------
 # create fstab then mount by it
 #
 mount -w /dev/rd0a /
 : > /boottmp/boot_starts

 #-------------------------------
 # scan devices
 # searching for where FuguIta is stored in
 #
 def_rdev=''
 for rdev in {cd0,sd{0,1,2,3}}a; do
     if mount -r /dev/$rdev /mnt 2>/dev/null ; then
         if [ -d /mnt/usr/nora ]; then
             def_rdev=$rdev
             umount /mnt
             break;
         fi
         umount /mnt
     fi
 done
 rdev=''

 #-------------------------------
 # set mfs size
 #
 memmax=1024
 memmin=32
 usermem=$((`sysctl -n hw.usermem`/1024/1024))
 if [ $memmax -lt $usermem ]; then
     usermem=$memmax
 fi
 defmem=$(($usermem/2))

 greet_pc98=NO

 if [ X"$greet_pc98" = XYES ]; then
     echo -n "[H[2JHow many megabytes(16-$usermem)? "; read umem
 else
     echo '==============================================
=     ______                __   _
=    / ____/               |  |_| |__
=   / /____  ______  __  __|  /_   _/_____
=  / ___/ / / / __ \/ / / /|  | | | /  _  |
= / /  / /_/ / /_/ / /_/ / |  | | |_| (_) |__
=/_/   \____/\__  /\____/  |__| \___/____/__/
=            __/ /
=           /___/
=
= Welcome to FuguIta - OpenBSD LiveCD!
=         http://kaw.ath.cx/openbsd/?en/LiveCD
==============================================
'
     echo "${usermem}MB of memory available for you."
     echo -n "your mfs size [$memmin to $usermem, default: $defmem]MB? -> "; read umem
 fi

 #-------------------------------
 # check mfs size
 #

 if [ X"$umem" = X ]; then
     echo "set mfs size to default: ${defmem}MB"
     umem=$defmem
 elif [ $umem -lt $memmin ]; then
     echo "set mfs size to minimum limit: ${memmin}MB"
     umem=$memmin
 elif [ $memmax -lt $umem ]; then
     echo "set mfs size to maximum limit: ${memmax}MB"
     umem=$memmax
 else
     echo "set mfs size to ${umem}MB"
 fi

 #-------------------------------
 # ask which system-stored device is.
 #
 if [ X"$def_rdev" = X ]; then
     echo -n "device where FuguIta stored in? -> "; read ans
 else
     echo -n "device where FuguIta stored in [${def_rdev}]? -> "; read ans
 fi

 if [ X"$ans" = X ]; then
     rdev=$def_rdev
 else
     rdev=$ans
 fi

 #-------------------------------
 # mount system-stored device
 # and user-writable file system
 #
 mfs_alloc_blk=$((1024*2*$umem))

 /sbin/mount -r /dev/${rdev} /fuguita || exit
 /fuguita/sbin/mount_mfs -o rw,async -b 4096 -f 512 -i 1024 -s $mfs_alloc_blk swap /mfs || exit

 #-------------------------------
 # generate fstab from current
 # mounting status
 #
 /sbin/mount | \
 while read ln; do
     set - $ln
     case X"$3"X in
         X/X)
             echo /dev/rd0a / ffs rw 0 0 ;;
         X/fuguitaX)
             echo $1 $3 $5 ro 0 0 ;;
         X/mfsX)
             echo swap $3 $5 rw,async,-b=4096,-f=512,-i=1024,-s=$mfs_alloc_blk 0 0 ;;
         *)
             echo $1 $3 $5 defaults 0 0 ;;
     esac
 done >/boottmp/fstab

 #----------------------------
 # re-link bin dirs to System device
 #
 /fuguita/bin/rm -rf /bin /sbin
 /fuguita/bin/ln -sf fuguita/bin fuguita/sbin .

 while :; do
     echo 'Select boot mode;'
     echo '   0: clean boot'
     echo '   1: clean boot (lower memory, faster boot)'
     echo '   2: retrieve user data from USB flash memory'
     echo '   3: retrieve user data from floppy disk'
     echo '   4: interactive shell for debugging'
     echo -n '-->'; read setup_rw_mode

     case X"$setup_rw_mode" in

	 #-----------------------
	 #-----------------------
	 # System Storage only mode
	 #-----------------------
	 #-----------------------
	 #
	 X[01])
	 if [ X"$setup_rw_mode" = X0 ]; then
	     echo "manual"
	 elif [ X"$setup_rw_mode" = X1 ]; then
	     echo "manual_less_mfs"
	 fi > /boottmp/boot_mode

	 #-------------------------------------
	 # copy System Storage contents to rw-able mfs
	 #
	 echo "Running manual setup."
	 echo -n "Copying system files to /mfs ... "
	 cd /mfs
	 if [ X"$setup_rw_mode" = X0 ]; then
	     (cd ../fuguita && tar cf - altroot etc home tmp root var) | tar xpf -
	 elif [ X"$setup_rw_mode" = X1 ]; then
	     (cd ../fuguita && tar cf - altroot etc home tmp root var) \
	     | tar -x \
		   -p \
		   -f - \
		   -s '|^etc/X11/.*||' \
		   -s '|^var/dict/.*||' \
		   -s '|^var/www/htdocs/.*||'
	 fi
	 echo "done"

	 #-----------------------
	 # symlink from / to mfs
	 #
	 cd /
	 rm -rf /tmp
	 mv /etc /bootetc
	 ln -sf mfs/* .
	 cp /boottmp/fstab /etc

	 #-------------------------------------------
	 # symlink rest of contents from / to System Storage
	 #
	 ln -s fuguita/* .     2>/dev/null
	 #ln -s fuguita/.??* . 2>/dev/null ; # Maybe not needed

	 if [ X"$setup_rw_mode" = X0 ]; then
	     #-------------------------------------------
	     # lndir from /mfs/usr to /fuguita/usr
	     #
	     echo -n "Linking files from /mfs to /fuguita ... "
	     mkdir /mfs/usr && cd /mfs/usr && lndir -s /fuguita/usr

	     #-------------------------------------------
	     # KLUDGE: Re-lndir under /usr/local/lib/X11/fonts
	     #
	     if [ -h /mfs/usr/local/lib/X11/fonts ]; then
		 rm /mfs/usr/local/lib/X11/fonts
		 mkdir -p /mfs/usr/local/lib/X11/fonts
		 (cd /mfs/usr/local/lib/X11/fonts && lndir -s /fuguita/usr/local/lib/X11/fonts)
	     fi

	     #-------------------------------------------
	     # set time stamp of dirs containing font files
	     # (to avoid re-build font caches)
	     #
	     (cd /mfs && for d in usr/*/lib/X11/fonts/*; do touch -cm -r /fuguita/$d $d; done)

	     #-------------------------------------------
	     # Then, copy again for trivial dirs
	     #
	     for d in \
		 usr/libexec/auth \
		 usr/local/lib/wnn
	       do
	       if [ -d /mfs/$d ]; then
		   rm -rf /mfs/$d && cd `dirname /fuguita/$d` && pax -rwpe `basename $d` `dirname /mfs/$d`
	       fi
	     done

	     cd / && ln -sf mfs/usr .
	 elif [ X"$setup_rw_mode" = X1 ]; then
	     (cd /mfs/etc/X11        && lndir -s /fuguita/etc/X11)
	     (cd /mfs/var/dict       && lndir -s /fuguita/var/dict)
	     (cd /mfs/var/www/htdocs && lndir -s /fuguita/var/www/htdocs)
	 fi

	 echo "done"

	 #========================================
	 # setup in /etc (network etc...)
	 #
	 echo ""

	 echo "Set your keyboard type;"
	 while :; do
	     echo -n `kbd -l`
	     echo -n ' -> '; read kbtype
	     if kbd $kbtype; then
		 echo $kbtype > /etc/kbdtype
		 break
	     fi
	 done

	 echo "Please wait ... "
	 until passwd root
	   do
	   echo "passwd failed, Try again."
	 done

	 echo -n 'your host name (without domain)? -> '; read myhost
	 if [ X"$myhost" = X ]; then
	     myhost=fuguita
	 fi
	 echo $myhost >/etc/myname

	 #-----------------------
	 # Network configuration
	 #
	 ifconfig_out=`ifconfig -a`
	 nicifs=`echo "$ifconfig_out" | grep ' mtu 1500$' | cut -d: -f1`
	 if [ X"$nicifs" = X ]; then
	     echo 'No available network interfaces found.'
	     ipv='n'
	 else
	     echo -n 'Setting up IP network configurations? [n, 4, 6 or 46]-> '; read ipv
	     set - $nicifs
	     nicifs="$@"
	     defnic="$1"
	 fi

	 case X"$ipv" in
	     #-----------------------
	     # IP-generic configs
	     #
	     X*[46]*)
		 echo "========================================"
		 echo "$ifconfig_out"
		 echo "========================================"
		 echo "Available network interface(s): $nicifs"
		 echo -n "your network interface? [$defnic] -> "; read mynic
		 if [ X"$mynic" = X ]; then
		     mynic=$defnic
		 fi
		 : > /etc/hostname.$mynic
		 chmod 0640 /etc/hostname.$mynic

		 echo "lookup file bind" > /etc/resolv.conf
		 echo -n "your FQDN? -> ${myhost}."; read mydomain
		 if [ ! X"$mydomain" = X ]; then
		     myfqdn=${myhost}.${mydomain}
		     echo "search $mydomain" >> /etc/resolv.conf
		     echo $myfqdn > /etc/myname
		 fi

		 echo '127.0.0.1 localhost'  > /etc/hosts
		 echo '::1       localhost' >> /etc/hosts

		 echo    'your DNS servers?'
		 echo    '(up to three IPv4/6 addresses, separated by spaces)'
		 echo    '(for DHCP, just press ENTER)'
		 echo -n '-> '; read mydns
		 mydns=`echo -n $mydns | tr -cs '0-9A-Za-z:.%' ' '`
		 if [ ! X"$mydns" = X ]; then
		     set $mydns >/dev/null
		     [ ! X"$1" = X ] && echo "nameserver $1"          >> /etc/resolv.conf
		     [ ! X"$2" = X ] && shift && echo "nameserver $1" >> /etc/resolv.conf
		     [ ! X"$2" = X ] && shift && echo "nameserver $1" >> /etc/resolv.conf
		 fi

		 #-----------------------
		 # IPv4 configs
		 #
		 case X"$ipv" in
		     X*4*)
			 echo 'your IPv4 addr? (for DHCP, just press ENTER)'
			 echo -n '-> '; read myv4addr
			 if [ X"$myv4addr" = X ]; then
			     echo "dhcp" >> /etc/hostname.$mynic
			 else
			     echo -n 'your netmask? -> '; read mynetmask
			     echo -n 'your default gateway? -> '; read mygw

			     echo "inet $myv4addr $mynetmask NONE" >> /etc/hostname.$mynic
			     echo "$mygw" > /etc/mygate
			     echo "$myv4addr $myfqdn ${myfqdn%%.*}"        >> /etc/hosts
			 fi
			 ;;
		 esac

		 #-----------------------
		 # IPv6 configs
		 #
		 case X"$ipv" in
		     X*6*)
			 echo 'rtsol' >> /etc/hostname.$mynic
			 echo "rtsold_flags=$mynic" >> /etc/rc.conf.local
			 echo 'net.inet6.ip6.forwarding=0'   >> /etc/sysctl.conf
			 echo 'net.inet6.ip6.accept_rtadv=1' >> /etc/sysctl.conf
			 ;;
		 esac
		 ;;
	 esac

	 echo -n 'Generate cryptographic keys? -> '; read ans
	 case X"$ans" in
	     X[Yy])
	     rm -f /etc/ssh/*_key* /etc/isakmpd/private/local.key
	     ;;
	 esac

	 break
	 ;;

	 #-----------------------
	 #-----------------------
	 # Restore from USB flash mode
	 #-----------------------
	 #-----------------------
	 #
	 X2)
	 echo "usbflash" > /boottmp/boot_mode

	 #-----------------------
	 # search USB mass storage
	 # (works on a subshell not to destroy positional parameters...)
	 #
	 ( set X `dmesg | while read ln; do case Y"$ln" in Yscsibus[0-9]" at "umass[0-9]*) echo $ln;; esac; done`
	 if [ $# -gt 2 ]; then
		 usb_scsi_umass=${2%:}
		 usb_umass=$4

		 set X `dmesg | while read ln; do case Y"$ln" in Ysd[0-9]" at "scsibus[0-9]*) echo $ln;; esac; done`
		 if [ $# -gt 2 ]; then
			 usb_sd=$2
			 usb_sd_scsi=$4
			 if [ "$usb_scsi_umass" = "$usb_sd_scsi" ]; then
			     echo "USB flash memory found as $usb_sd"
			 else
			     echo "SCSI bus between sd($usb_sd at $usb_sd_scsi) and umass($usb_scsi_umass at $usb_umass) not match"
			     exit 1
			 fi
		 else
		     echo 'SCSI-simulated USB disk storage not found'
		     exit 1
		 fi
	 else
	     echo 'USB mass storage device not found'
	     exit 1
	 fi

	 usb_devname=/dev/${usb_sd}d
	 echo "$usb_devname" > /boottmp/boot_restore_devname )

	 #-----------------------
	 # mount user's storage
	 #
	 if mount -r `cat /boottmp/boot_restore_devname` /mnt; then
	     #-----------------------
	     # select config files
	     #
	     if [ ! -d /mnt/livecd-config ]; then
		 echo 'cannot find config dir'
		 exit 1
	     fi

	     while :; do
		 echo 'available configs;'
		 (cd /mnt/livecd-config && echo ""; ls -C; echo "")
		 echo -n 'your config name? -> '; read confdir
		 if [ -d "/mnt/livecd-config/$confdir" ]; then
		     echo "$confdir" > /boottmp/boot_user_config
		     break
		 else
		     echo 'cannot find config dir'
		 fi
	     done

	     #-----------------------
	     # copying to mfs
	     #
	     echo -n "Copying files from flash to mfs ... "
	     cd /mnt/livecd-config/$confdir && pax -rwpe . /mfs
	     echo "done"

	     #-----------------------
	     # symlink from / to mfs
	     #
	     cd /
	     rm -rf /tmp
	     mv /etc /bootetc
	     ln -sf mfs/* .
	     cp /boottmp/fstab /etc

	     #-------------------------------------------
	     # symlink rest of contents from / to System Storage
	     #
	     ln -s fuguita/* .     2>/dev/null
	     #ln -s fuguita/.??* . 2>/dev/null ; # Maybe not needed

	     umount /mnt
	 else
	     echo "Failed to mount user's storage"
	     exit 1
	 fi

	 break
	 ;;

	 #-----------------------
	 #-----------------------
	 # Restore from floppy mode
	 #-----------------------
	 #-----------------------
	 #
	 X3)
	 echo "floppy" > /boottmp/boot_mode

	 #-----------------------
	 # copying to mfs
	 #
	 if mount -r /dev/fd0a /mnt; then
	     if [ -r /mnt/livecd-retr.sh.inc ]; then
		 cp -p /boottmp/livecd-retr.sh.inc /boottmp/livecd-retr.sh.inc.orig
		 cat /mnt/livecd-retr.sh.inc > /boottmp/livecd-retr.sh.inc
		 .  /boottmp/livecd-retr.sh.inc
	     else
		 echo "Retrieving script not found on fd0a."
		 exit 1
	     fi
	     umount /mnt
	 else
	     echo "Failed to read /mnt/livecd-config.tar.gz on /dev/fd0a"
	     exit 1
	 fi

	 break
	 ;;

	 #-----------------------
	 #-----------------------
	 # Interactive shell mode
	 #-----------------------
	 #-----------------------
	 #
	 X4)
	 echo "intr-shell" > /boottmp/boot_mode
	 echo "==INTERACTIVE SHELL MODE================
 =
 = An interactive shell invoked for manual operation.
 = Now, just System Storage mounted on /fuguita.
 =
 = After exit this shell, rest of boot sequence will follow.
 =
 ========================================"
	 PATH="/fuguita/sbin:/fuguita/bin" /fuguita/bin/sh

	 /fuguita/sbin/umount /mfs
	 /fuguita/sbin/umount /fuguita

	 break
	 ;;

	 *) echo "What?" ;;
     esac
 done

 #====================
 # remove unused files
 #
 rm -f /boot.catalog /cdboot /cdbr /rr_moved

 echo "========================================"
 date > /boottmp/boot_livecd_rc_ends

 #========================================
 # chain original /etc/rc
 #
 ) # close the first line

. /etc/rc
