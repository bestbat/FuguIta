#!/boottmp/sh

#========================================
#
# fiupdate - live updater for FuguIta
# KAWAMATA, Yoshihiro / kaw@on.rim.or.jp
# $Id: fiupdate,v 1.5 2020/10/04 16:16:36 kaw Exp $
#
#========================================

# Copyright (c) 2020
# Yoshihiro Kawamata
#
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
# 
#   * Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 
#   * Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in
#     the documentation and/or other materials provided with the
#     distribution.
# 
#   * Neither the name of Yoshihiro Kawamata nor the names of its
#     contributors may be used to endorse or promote products derived
#     from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#===================
# Utility functions
#===================

#-------------------
# ask user yes or no
# outputs answer to stdout
#
#     usage: ask_yn prompt yn
#
#       yn ... y: defaults to yes
#              n: defaults to no
#              r: no default ... ask again
#              else: no default ... return -1 if answered not yn
#
#       output ... 1: yes, 0: no, -1: else yn, -2: error occured
#
function ask_yn {

    if [ -z "$2" ]; then
        echo -2 >&2
        return
    fi

    local prompt="$1"; shift
    local yn_default="$1"; shift
    local yn_ans

    case X"$yn_default"X in
        X[Yy]X) yn_default=Y; prompt="$prompt [Y/n] -> " ;;
        X[Nn]X) yn_default=N; prompt="$prompt [y/N] -> " ;;
        X[Rr]X) yn_default=R; prompt="$prompt [y/n] -> " ;;
        *)      yn_default=E; prompt="$prompt [y/n] -> " ;;
    esac

    while :; do
        echo -n "$prompt" >&2; read yn_ans

        case X"$yn_ans"X in
            X[Yy]X) echo 1; return;;
            X[Nn]X) echo 0; return;;
            XX)
                case X"$yn_default"X in
                    XYX) echo 1;  return;;
                    XNX) echo 0;  return;;
                    XRX) continue;;
                    *)   echo -1; return;;
                esac;;
            *)
                continue;;
        esac
    done
}

#-------------------
# read user's input with readline functionality
# outputs echoed to stdout
#
#     usage: rl_wread prompt-str default-str [completion words ....]
#
function rl_wread {
    local prompt="$1";  shift
    local default="$1"; shift
    local rl_words=$(mktemp)
    local w

    if [ -x /usr/local/bin/rlwrap ]; then
        echo "$@" > $rl_words
        rlwrap -b '' \
               -f $rl_words \
               -P "$default" \
               sh -f -c 'echo -n "'"$prompt"'->" >&2 ; read w || echo EOF; echo $w' || echo RL_ERR
    else
        #-------------------
        # fallback to dumb input
        #
        if [ X"$default" = X ]; then
            echo -n "${prompt}->" >&2
            read w
        else
            echo -n "$prompt [$default] -> " >&2
            read w
            if [ X"$w" = X ]; then
              w="$default"
            fi
        fi
        echo $w
    fi
}

#-------------------
# ask selection out of multiple items
# outputs answer to stdout
#
#     usage: ask_which prompt default item1 item2 ...
#
#       Note: although user's choice is one originated
#             default is zero originated
#
#       output: first word of selected item
#               returns empty line unless selected normally
#
function ask_which {
    if [ $# -lt 3 ]; then
        return
    fi

    local prompt="$1";  shift
    local default="$1"; shift
    local i item val

    # skip null item
    #
    i=0
    for val in "$@"; do
        if [ -n "$val" ]; then
           item[$i]="$val"
           i=$((i+1))
        fi
    done

    # only one item is default itself
    #
    [ "${#item[@]}" = 1 ] && default=${item[0]}

    i=0
    while [ -n "${item[$i]}" ]; do
        if [ "$default" = "${item[$i]}" ]; then
            OIFS="$IFS"
            IFS= prompt="$prompt\n"`printf '%3d: [%s]' $((i+1)) ${item[$i]}`
            IFS="$OIFS"
        else
            OIFS="$IFS"
            IFS= prompt="$prompt\n"`printf '%3d:  %s' $((i+1)) ${item[$i]}`
            IFS="$OIFS"
        fi
        i=$((i+1))
    done
    echo "$prompt" >&2

    local ans
    ans=`rl_wread '' ''`

    # take first argument
    #
    set -- $ans
    ans=$1
    
    # return selected item
    #
    if expr "$ans" : '^[0-9][0-9]*$' >/dev/null && \
       [ "$ans" -le ${#item[@]} ]; then
        set -- ${item[$((ans-1))]}
        echo $1
    elif [ -n "$default" -a -z "$ans" ]; then
        set -- $default
        echo $1
    fi
}

# display usage
#
usage () {
    cat <<EOT >&2
Usage: ${PROGNAME} yyyymmddn

You should locate FuguIta-${REL}-${ARCH}-yyyymmddn.iso.gz and MD5
at current directory before invoke this.
EOT
}

# echo to stderr
#
echo2 () {
    echo "$@" >&2
}

# check existing kernels/ffsimg
#
check_kern_ffsimg () {
    readonly FFSIMG=/sysmedia/fuguita-${REL}-${ARCH}.ffsimg
    readonly BSDFI=/sysmedia/bsd-fi
    readonly BSDFI_MP=/sysmedia/bsd-fi.mp

    if [ ! -f $FFSIMG ]; then
        echo2 "$FFSIMG not found (other version/arch ?)"
        ls -l /sysmedia >&2
        exit 1
    fi

    if [ ! -f $BSDFI ]; then
        echo2 "$BSDFI not found (device for saving data only?)"
        ls -l /sysmedia >&2
        exit 1
    fi

    if [ ! -f $BSDFI_MP ]; then
        echo2 "$BSDFI_MP not found (device for saving data only?)"
        ls -l /sysmedia >&2
        exit 1
    fi
}

# check mount status
#
check_mnttype () {
    local mount_out=$(mount)  # cache mount's output
    local mnttype=unknown

    if echo "$mount_out" | grep -q '^/dev/.* on /sysmedia-iso type '; then
	if echo "$mount_out" | grep -q '/sysmedia-iso type ntfs'; then
            mnttype=sys-iso-ntfs  # NTFS with only R/O, can't update
	else
            mnttype=sys-iso
	fi
    elif echo "$mount_out" | grep -q '^/dev/cd.* on /sysmedia type '; then
        echo2 "cannot update LiveDVD. Burn another one to update."
    elif ! echo "$mount_out" | grep -q '^/dev/.* on /sysmedia type '; then
        echo2 "system partition not mounted (boot mode 2?)"
        mnttype=mode2
    else
        mnttype=liveusb
    fi

    echo $mnttype
}

# decompress ISO image
#
decompress_iso () {
    rm -f ${FI}.iso
    echo
    echo "decompressing ${FI}.iso.gz..."
    pv ${FI}.iso.gz | gzip -d -o ${FI}.iso || exit 1
}

# setup update environment
#   mount *.ISO as a vnode device
#
setup_iso_content () {
    # mount vnode device
    mkdir ${FI}
    vnconfig vnd0 ${FI}.iso
    mount -r /dev/vnd0a ${FI}
}

# copy executables these are needed to overwrite filesystem image
# to TMPFS
#
setup_rampath () {
    mkdir -p /ram/fiupdate.bin
    cp -p /bin/{cat,echo,rm,rmdir,sleep,sync} /sbin/reboot /usr/local/bin/pv \
       /ram/fiupdate.bin/.
    PATH=/ram/fiupdate.bin:/boottmp:$PATH
    export PATH
}

# comfirm update to an user
#
confirm_exec () {
    cat <<EOT

Now ready to update FuguIta-$(cat /usr/fuguita/version) to ${FI}.

This machine will reboot immediately after update completed.

EOT
    if [ 1 != `ask_yn "Do you proceed?" n` ]; then
        cleanups
        exit
    fi
}

# stop all daemons
#
stop_srvs () {
    local daemon
    echo2 "stopping daemons..."
    for daemon in $(rcctl ls started); do
        rcctl stop $daemon
    done
}

# rewrite kernels and ffsimg at mode 0 or 1
#
update_liveusb () {
    echo2 "overwriting uniprocessor kernel..."
    pv ${FI}/bsd-fi > $BSDFI

    echo2 "overwriting multiprocessor kernel..."
    pv ${FI}/bsd-fi.mp > $BSDFI_MP

    echo2 "overwriting filesystem image..."
    pv ${FI}/fuguita-${REL}-${ARCH}.ffsimg > $FFSIMG

    echo
    echo2 "update completed. now rebooting..."
}

# make disk/partition list, then echo to stdout
#
list_diskpart () {
    local disk part part_list
    for disk in $(sysctl -n hw.disknames|tr , ' '); do
        for part in $(disklabel ${disk%:*} 2>/dev/null \
                          | sed -e "/^  [ad-p]: /!d; s/^  \\([ad-p]\\):.*/${disk%:*}\1/"); do
            part_list="${part_list:+$part_list }$part"
        done
    done
    echo $part_list
}

# find UNMOUNTED FuguIta's system disk/partition
#
find_free_fisys () {
    local part fisys
    for part in $(list_diskpart); do
        case "$part" in
            sd*|wd*)
                if mount -r /dev/$part /mnt 2> /dev/null; then
                    if [ -f /mnt/bsd-fi.mp ]; then
                        fisys="${fisys:+$fisys }$part"
                    fi
                    umount /dev/$part
                fi
                ;;
        esac
    done
    echo $fisys
}

# check if single FuguIta's boot device attached
# if success appropriate device set to gloobal
# variable BOOTDEV
#
check_boot_fisys () {
    set -- $(find_free_fisys)
    if [ $# -le 0 ]; then
        echo2 "No FuguIta boot device found"
        echo2 "Please attach single FuguIta boot device."
        exit 1
    elif [ $# -eq 1 ]; then
        BOOTDEV="$1"
    elif [ $# -gt 1 ]; then
	cat <<EOT >&2
checked

Multiple FuguIta boot devices found: $*
Please attach single FuguIta boot device.
EOT
        exit 1
    else
        echo2 "Something wrong in scanning disks"
        exit 1
    fi
}

# rewrite running ISO image,
# kernels used for boot and
# correnponding ffsimg
#
update_sys_iso () {
    # update ISO image file
    #
    echo2 "overwriting /sysmedia-iso/ISO/${FI}.iso ..."
    if ! pv ${FI}.iso > /sysmedia-iso/ISO/${FI}.iso; then
        rm -f /sysmedia-iso/ISO/${FI}.iso
        cleanups
        exit 1
    fi

    # update kernel and ffsimg at boot device
    #
    if mount /dev/$BOOTDEV /mnt; then
        if [ -f /mnt/bsd-fi ]; then
            echo2 "overwriting uniprocessor kernel..."
            pv ${FI}/bsd-fi > /mnt/bsd-fi
        fi

        if [ -f /mnt/bsd-fi.mp ]; then
            echo2 "overwriting multiprocessor kernel..."
            pv ${FI}/bsd-fi.mp > /mnt/bsd-fi.mp
        fi

        if [ -f /mnt/fuguita-${REL}-${ARCH}.ffsimg ]; then
            echo2 "overwriting filesystem image..."
            pv ${FI}/fuguita-${REL}-${ARCH}.ffsimg > /mnt/fuguita-${REL}-${ARCH}.ffsimg
        fi

        umount /mnt
    else
        cleanups
        exit 1
    fi

    echo
    echo2 "update completed. now rebooting..."
}

#==================================
# Active Code from HERE.
#==================================

# systemwide constants
#
readonly PROGNAME=${0##*/}
readonly REL=$(uname -r)
readonly ARCH=$(uname -m)

# greetings and notices
#
cat <<EOT

fiupdate - Live Updater for FuguIta LiveUSB
  Version/Arch: $REL/$ARCH  (FuguIta-`cat /usr/fuguita/version`)

EOT

if [ -z "$1" ]; then
    echo2 "$PROGNAME: version string not specified\n"
    usage
    exit
else
    readonly FI="FuguIta-${REL}-${ARCH}-${1}"
fi

# check environment
#
echo2 -n "Checking:\n     environment: "
if [ ! "$(id -un)" = root ]; then
    echo2 "You are not root."
    exit 1
elif [ ! -e /usr/fuguita/version ]; then
    echo2 "You are not running FuguIta."
    exit 1
elif [ 0 -lt $(expr $(tty) : '/dev/ttyp[0-9]') ]; then
    cat <<EOT >&2
checked

It seems you are running this script on X Window System,
or via network.
In this situation, during update, corresponding processes
will be killed and then update will fail.

Please do this on direct console device.
EOT
    exit 1
else
    echo2 "ok"
fi

cat <<EOT

Note: This sorftware is now under beta test.
      Please use this at YOUR OWN RISK.

We recommend that you execute this command with fresh boot (boot mode 0 or 1).

Or you should quit all application softwares and save all your data
before you update this FuguIta device.

EOT

if [ 1 != `ask_yn "Do you proceed?" n` ]; then
    exit
fi
echo

# check download file
#
echo2 -n "Checking:\n        checksum: "
if [ ! -e ${FI}.iso.gz -a -e ${FI}.img.gz ]; then
    echo2 "You need a file ${FI}.iso.gz, NOT ${FI}.img.gz"
    exit 1
else
    md5 -C MD5 ${FI}.iso.gz || exit 1
fi

echo2 -n "      type of FS: "
MNTTYPE=$(check_mnttype)
echo2 $MNTTYPE

case $MNTTYPE in
    liveusb)
        echo2 -n "  existing files: "
        check_kern_ffsimg
        echo2 "ok"

        # define terminate session
        #
        cleanups () { mount -ur /sysmedia
                      umount -f ${FI}
                      rmdir ${FI}
                      vnconfig -u vnd0
                      rm ${FI}.iso
                      rm -rf /ram/fiupdate.bin; }

        decompress_iso
        setup_iso_content

        setup_rampath
        confirm_exec
        
        if ! mount -uw /sysmedia; then
            cleanups
            exit 1
        fi
        stop_srvs
        update_liveusb

        # detach devices
        #
        umount -f /dev/vnd5a  # vnd5 is /sysmedia/fuguita-*.ffsimg
        vnconfig -u vnd5      # which is mounted on /fuguita

        umount -f /sysmedia
        ;;
    sys-iso)
        # define terminate session
        #
        cleanups () { mount -ur /sysmedia-iso
                      rm ${FI}.iso
                      rm -rf /ram/fiupdate.bin; }

        echo2 -n "     boot device: "
        check_boot_fisys
        echo2 "ok"

        decompress_iso
        setup_iso_content
        setup_rampath
        confirm_exec
        
        if ! mount -uw /sysmedia-iso; then
            cleanups
            exit 1
        fi
        stop_srvs
        update_sys_iso

        # detach devices
        #
        umount -f /dev/vnd5a  # vnd5 is /sysmedia/fuguita-*.ffsimg
        vnconfig -u vnd5      # which is mounted on /fuguita

        umount -f /dev/vnd4a  # vnd4 is /sysmedia-iso/ISO/FuguIta-*-*.iso
        vnconfig -u vnd4      # which is mounted on /sysmedia

        umount -f /sysmedia-iso
        ;;
    sys-iso-ntfs)
        cleanups () { rm -rf /ram/fiupdate.bin; }

	echo2 "We can't update because NTFS is mounted on /sysmedia-iso with read only."
	echo2 "Please locate the ISO file to \\ISO\\${FI}.iso on running Windows OS."
	echo2 "Sorry for inconvenience."

        cleanups
	exit 1
	;;
    mode2)
	exit 1
	;;
    *)
	exit 1
	;;
esac

# not to perform usbfadm -r
#
if [ -f /etc/rc.shutdown ]; then
    mv /etc/rc.shutdown /etc/DISABLED.rc.shutdown
fi

# reboot ... this is it.
#
sync; sync; sync; sleep 5
reboot
