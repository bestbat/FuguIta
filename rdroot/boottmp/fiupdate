#!/boottmp/sh

#========================================
#
# fiupdate - live updater for FuguIta
# KAWAMATA, Yoshihiro / kaw@on.rim.or.jp
# $Id: fiupdate,v 1.3 2020/10/03 05:27:50 kaw Exp $
#
#========================================

# Copyright (c) 2020
# Yoshihiro Kawamata
#
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
# 
#   * Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 
#   * Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in
#     the documentation and/or other materials provided with the
#     distribution.
# 
#   * Neither the name of Yoshihiro Kawamata nor the names of its
#     contributors may be used to endorse or promote products derived
#     from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#==================================
# Utility functions and subcommands
#==================================

#-------------------
# ask user yes or no
# outputs answer to stdout
#
#     usage: ask_yn prompt yn
#
#       yn ... y: defaults to yes
#              n: defaults to no
#              r: no default ... ask again
#              else: no default ... return -1 if answered not yn
#
#       output ... 1: yes, 0: no, -1: else yn, -2: error occured
#
function ask_yn {

    if [ -z "$2" ]; then
        echo -2 >&2
        return
    fi

    local prompt="$1"; shift
    local yn_default="$1"; shift
    local yn_ans

    case X"$yn_default"X in
        X[Yy]X) yn_default=Y; prompt="$prompt [Y/n] -> " ;;
        X[Nn]X) yn_default=N; prompt="$prompt [y/N] -> " ;;
        X[Rr]X) yn_default=R; prompt="$prompt [y/n] -> " ;;
        *)      yn_default=E; prompt="$prompt [y/n] -> " ;;
    esac

    while :; do
        echo -n "$prompt" >&2; read yn_ans

        case X"$yn_ans"X in
            X[Yy]X) echo 1; return;;
            X[Nn]X) echo 0; return;;
            XX)
                case X"$yn_default"X in
                    XYX) echo 1;  return;;
                    XNX) echo 0;  return;;
                    XRX) continue;;
                    *)   echo -1; return;;
                esac;;
            *)
                continue;;
        esac
    done
}

# display usage
#
usage () {
    cat <<EOT >&2
Usage: ${PROGNAME} yyyymmddn

You should locate FuguIta-${REL}-${ARCH}-yyyymmddn.iso.gz and MD5
at current directory before invoke this.
EOT
}

# echo to stderr
#
echo2 () {
    echo "$@" >&2
}

# check existing kernels/ffsimg
#
check_kern_ffsimg () {
    ffsimg=/sysmedia/fuguita-${REL}-${ARCH}.ffsimg
    bsdfi=/sysmedia/bsd-fi
    bsdfi_mp=/sysmedia/bsd-fi.mp

    if [ ! -f $ffsimg ]; then
        echo2 "$ffsimg not found (other version/arch ?)"
        ls -l /sysmedia >&2
        exit 1
    fi

    if [ ! -f $bsdfi ]; then
        echo2 "$bsdfi not found (device for saving data only?)"
        ls -l /sysmedia >&2
        exit 1
    fi

    if [ ! -f $bsdfi_mp ]; then
        echo2 "$bsdfi_mp not found (device for saving data only?)"
        ls -l /sysmedia >&2
        exit 1
    fi
}

# check mount status
#
check_mnttype () {
    local mount_out=$(mount)  # cache mount's output
    local mnttype

    if echo "$mount_out" | grep -q '^/dev/.* on /sysmedia-iso type '; then
        echo2 "cannot support 'sysmedia-iso' mount type"
        exit 1
        mnttype=sys-iso
    elif echo "$mount_out" | grep -q '^/dev/cd.* on /sysmedia type '; then
        echo2 "cannot update LiveDVD. Burn another one to update."
        exit 1
    elif ! echo "$mount_out" | grep -q '^/dev/.* on /sysmedia type '; then
        echo2 "system partition not mounted (boot mode 2?)"
        exit 1
        mnttype=mode2
    else
        mnttype=liveusb
    fi

    echo $mnttype
}

# setup update environment
#    - decompress ISO image
#    - mount it as a vnode device
#
setup_iso_content () {
    rm -f ${FI}.iso
    echo
    echo "decompressing ${FI}.iso.gz..."
    pv ${FI}.iso.gz | gzip -d -o ${FI}.iso || exit 1
    
    # mount vnode device
    mkdir ${FI}
    vnconfig vnd0 ${FI}.iso
    mount -r /dev/vnd0a ${FI}
}

# copy executables these are needed to overwrite filesystem image
# to TMPFS
#
setup_rampath () {
    mkdir -p /ram/fiupdate.bin
    cp -p /bin/{cat,echo,rm,rmdir,sleep,sync} /sbin/{reboot,umount} /usr/local/bin/pv \
       /ram/fiupdate.bin/.
    PATH=/ram/fiupdate.bin:/boottmp:$PATH
    export PATH
}

# comfirm update to an user
#
confirm_exec () {
    cat <<EOT

Now ready to update FuguIta-$(cat /usr/fuguita/version) to ${FI}.

This machine will reboot immediately after update completed.

EOT
    if [ 1 != `ask_yn "Do you proceed?" n` ]; then
        cleanups
        exit
    fi
}

stop_all_srv () {
    echo2 "stopping all daemons..."
    for daemon in $(rcctl ls started); do
        rcctl stop $daemon
    done
}

update_liveusb () {
    echo2 "overwriting uniprocessor kernel..."
    pv ${FI}/bsd-fi > $bsdfi

    echo2 "overwriting multiprocessor kernel..."
    pv ${FI}/bsd-fi.mp > $bsdfi_mp

    echo2 "overwriting filesystem image..."
    pv ${FI}/fuguita-${REL}-${ARCH}.ffsimg > $ffsimg

    echo
    echo2 "update completed. now rebooting..."
}

#==================================
# Active Code from HERE.
#==================================

# systemwide constants
#
PROGNAME=${0##*/}
REL=$(uname -r)
ARCH=$(uname -m)

cat <<EOT

fiupdate - Live Updater for FuguIta LiveUSB
  Version/Arch: $REL/$ARCH  (FuguIta-`cat /usr/fuguita/version`)

EOT

if [ -z "$1" ]; then
    echo2 "$PROGNAME: version string not specified\n"
    usage
    exit
else
    FI="FuguIta-${REL}-${ARCH}-${1}"
fi

cat <<EOT
Note: This sorftware is now under beta test.
      Please use this at YOUR OWN RISK.

We recommend that you execute this command with fresh boot (boot mode 0 or 1).

Or you should quit all application softwares and save all your data
before you update this FuguIta device.

EOT

if [ 1 != `ask_yn "Are you sure?" n` ]; then
    exit
fi
echo

# check environment
#
echo2 -n "Checking:\n     environment: "
if [ ! "$(id -un)" = root ]; then
    echo2 "You are not root."
    exit 1
fi
if [ ! -e /usr/fuguita/version ]; then
    echo2 "You are not running FuguIta."
    exit 1
fi
echo2 "ok"

# check download file
#
echo2 -n "        checksum: "
if [ ! -e ${FI}.iso.gz -a -e ${FI}.img.gz ]; then
    echo2 "You need a file ${FI}.iso.gz, NOT ${FI}.img.gz"
    exit 1
else
    md5 -C MD5 ${FI}.iso.gz || exit 1
fi

echo2 -n "          mounts: "
MNTTYPE=$(check_mnttype)
echo2 "ok"

echo2 -n "  existing files: "
check_kern_ffsimg
echo2 "ok"

setup_iso_content

case $MNTTYPE in
    liveusb)
        # define terminate session
        #
        cleanups () {
            mount -ur /sysmedia
            umount -f ${FI}
            rmdir ${FI}
            vnconfig -u vnd0
            rm ${FI}.iso
            rm -rf /ram/fiupdate.bin
        }
        setup_rampath
        confirm_exec
        
        if ! mount -uw /sysmedia; then
            cleanups
            exit 1
        fi
        stop_all_srv
        update_liveusb

        # detach devices
        #
        umount -f /dev/vnd5a  # vnd5 is /sysmedia/fuguita-*.ffsimg
        vnconfig -u vnd5      # which is mounted on /fuguita
        umount -f /sysmedia
        ;;
esac

# not to perform usbfadm -r
#
if [ -f /etc/rc.shutdown ]; then
    mv /etc/rc.shutdown /etc/DISABLED.rc.shutdown
fi

sync; sync; sync; sleep 5
reboot
